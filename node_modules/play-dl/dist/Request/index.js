"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.request = exports.request_stream = void 0;
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const url_1 = require("url");
const cookie_1 = require("../YouTube/utils/cookie");
const classes_1 = require("./classes");
/**
 * Main module which play-dl uses to make a request to stream url.
 * @param url URL to make https request to
 * @param options Request options for https request
 * @returns IncomingMessage from the request
 */
function request_stream(req_url, options = { method: 'GET' }) {
    return new Promise(async (resolve, reject) => {
        let res = await https_getter(req_url, options).catch((err) => err);
        if (res instanceof Error) {
            reject(res);
            return;
        }
        if (Number(res.statusCode) >= 300 && Number(res.statusCode) < 400) {
            res = await request_stream(res.headers.location, options);
        }
        resolve(res);
    });
}
exports.request_stream = request_stream;
/**
 * Main module which play-dl uses to make a proxy or normal request
 * @param url URL to make https request to
 * @param options Request options for https request
 * @returns body of that request
 */
function request(req_url, options = { method: 'GET' }) {
    return new Promise(async (resolve, reject) => {
        if (!(options === null || options === void 0 ? void 0 : options.proxies) || options.proxies.length === 0) {
            let data = '';
            let cookies_added = false;
            if (options.cookies) {
                let cook = (0, cookie_1.getCookies)();
                if (typeof cook === 'string' && options.headers) {
                    Object.assign(options.headers, { cookie: cook });
                    cookies_added = true;
                }
            }
            let res = await https_getter(req_url, options).catch((err) => err);
            if (res instanceof Error) {
                reject(res);
                return;
            }
            if (res.headers && res.headers['set-cookie'] && cookies_added) {
                res.headers['set-cookie'].forEach((x) => {
                    x.split(';').forEach((x) => {
                        var _a;
                        const arr = x.split('=');
                        if (arr.length <= 1)
                            return;
                        const key = (_a = arr.shift()) === null || _a === void 0 ? void 0 : _a.trim();
                        const value = arr.join('=').trim();
                        (0, cookie_1.setCookie)(key, value);
                    });
                });
                (0, cookie_1.uploadCookie)();
            }
            if (Number(res.statusCode) >= 300 && Number(res.statusCode) < 400) {
                res = await https_getter(res.headers.location, options);
            }
            else if (Number(res.statusCode) > 400) {
                reject(new Error(`Got ${res.statusCode} from the request`));
            }
            res.setEncoding('utf-8');
            res.on('data', (c) => (data += c));
            res.on('end', () => resolve(data));
        }
        else {
            let cookies_added = false;
            if (options.cookies) {
                let cook = (0, cookie_1.getCookies)();
                if (typeof cook === 'string' && options.headers) {
                    Object.assign(options.headers, { cookie: cook });
                    cookies_added = true;
                }
            }
            let res = await proxy_getter(req_url, options.proxies, options.headers).catch((e) => e);
            if (res instanceof Error) {
                reject(res);
                return;
            }
            if (res.headers && res.headers['set-cookie'] && cookies_added) {
                res.headers['set-cookie'].forEach((x) => {
                    x.split(';').forEach((x) => {
                        var _a;
                        const arr = x.split('=');
                        if (arr.length <= 1)
                            return;
                        const key = (_a = arr.shift()) === null || _a === void 0 ? void 0 : _a.trim();
                        const value = arr.join('=').trim();
                        (0, cookie_1.setCookie)(key, value);
                    });
                });
                (0, cookie_1.uploadCookie)();
            }
            if (res.statusCode >= 300 && res.statusCode < 400) {
                res = await proxy_getter(res.headers['location'], options.proxies, options.headers);
            }
            else if (res.statusCode > 400) {
                reject(new Error(`GOT ${res.statusCode} from proxy request`));
            }
            resolve(res.body);
        }
    });
}
exports.request = request;
/**
 * Chooses one random number between max and min number.
 * @param min Minimum number
 * @param max Maximum number
 * @returns Random Number
 */
function randomIntFromInterval(min, max) {
    let x = Math.floor(Math.random() * (max - min + 1) + min);
    if (x === 0)
        return 0;
    else
        return x - 1;
}
/**
 * Main module that play-dl uses for proxy.
 * @param req_url URL to make https request to
 * @param req_proxy Proxies array
 * @returns Object with statusCode, head and body
 */
function proxy_getter(req_url, req_proxy, headers) {
    return new Promise((resolve, reject) => {
        var _a, _b;
        const proxy = req_proxy[randomIntFromInterval(0, req_proxy.length)];
        const parsed_url = new url_1.URL(req_url);
        let opts;
        if (typeof proxy === 'string') {
            const parsed = new url_1.URL(proxy);
            opts = {
                host: parsed.hostname,
                port: Number(parsed.port),
                authentication: {
                    username: parsed.username,
                    password: parsed.password
                }
            };
        }
        else
            opts = {
                host: proxy.host,
                port: Number(proxy.port)
            };
        let req;
        if (!opts.authentication) {
            req = http_1.default.request({
                host: opts.host,
                port: opts.port,
                method: 'CONNECT',
                path: `${parsed_url.host}:443`
            });
        }
        else {
            req = http_1.default.request({
                host: opts.host,
                port: opts.port,
                method: 'CONNECT',
                path: `${parsed_url.host}:443`,
                headers: {
                    'Proxy-Authorization': `Basic ${Buffer.from(`${(_a = opts.authentication) === null || _a === void 0 ? void 0 : _a.username}:${(_b = opts.authentication) === null || _b === void 0 ? void 0 : _b.password}`).toString('base64')}`
                }
            });
        }
        req.on('connect', async function (res, socket) {
            const conn_proxy = new classes_1.Proxy(parsed_url, { method: 'GET', socket: socket, headers: headers });
            await conn_proxy.fetch();
            socket.end();
            resolve(conn_proxy);
        });
        req.on('error', (e) => reject(e));
        req.end();
    });
}
/**
 * Main module that play-dl uses for making a https request
 * @param req_url URL to make https request to
 * @param options Request options for https request
 * @returns Incoming Message from the https request
 */
function https_getter(req_url, options = {}) {
    return new Promise((resolve, reject) => {
        var _a, _b;
        const s = new url_1.URL(req_url);
        (_a = options.method) !== null && _a !== void 0 ? _a : (options.method = 'GET');
        const req_options = {
            host: s.hostname,
            path: s.pathname + s.search,
            headers: (_b = options.headers) !== null && _b !== void 0 ? _b : {},
            method: options.method
        };
        const req = https_1.default.request(req_options, resolve);
        req.on('error', (err) => {
            reject(err);
        });
        if (options.method === 'POST')
            req.write(options.body);
        req.end();
    });
}
//# sourceMappingURL=index.js.map