"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContinuationToken = exports.getPlaylistVideos = exports.playlist_info = exports.decipher_info = exports.video_info = exports.video_basic_info = exports.extractID = exports.yt_validate = void 0;
const index_1 = require("./../../Request/index");
const cipher_1 = require("./cipher");
const Video_1 = require("../classes/Video");
const Playlist_1 = require("../classes/Playlist");
const video_id_pattern = /^[a-zA-Z\d_-]{11,12}$/;
const playlist_id_pattern = /^PL[a-zA-Z\d_-]{16,41}$/;
const DEFAULT_API_KEY = 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8';
const video_pattern = /^((?:https?:)?\/\/)?(?:(?:www|m)\.)?((?:youtube\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|v\/)?)([\w\-]+)(\S+)?$/;
const playlist_pattern = /^((?:https?:)?\/\/)?(?:(?:www|m)\.)?(youtube\.com)\/(?:(playlist|watch))(.*)?((\?|\&)list=)PL[a-zA-Z\d_-]{16,41}(.*)?$/;
/**
 * Command to validate a YouTube url
 * @param url Url for validation
 * @returns type of url or false.
 */
function yt_validate(url) {
    if (url.indexOf('list=') === -1) {
        if (url.startsWith('https')) {
            if (url.match(video_pattern)) {
                let id;
                if (url.includes('youtu.be/'))
                    id = url.split('youtu.be/')[1].split(/(\?|\/|&)/)[0];
                else if (url.includes('youtube.com/embed/'))
                    id = url.split('youtube.com/embed/')[1].split(/(\?|\/|&)/)[0];
                else if (url.includes('youtube.com/shorts/'))
                    id = url.split('youtube.com/shorts/')[1].split(/(\?|\/|&)/)[0];
                else
                    id = url.split('watch?v=')[1].split(/(\?|\/|&)/)[0];
                if (id.match(video_id_pattern))
                    return 'video';
                else
                    return false;
            }
            else
                return false;
        }
        else {
            if (url.match(video_id_pattern))
                return 'video';
            else if (url.match(playlist_id_pattern))
                return 'playlist';
            else
                return 'search';
        }
    }
    else {
        if (!url.match(playlist_pattern))
            return false;
        else
            return 'playlist';
    }
}
exports.yt_validate = yt_validate;
/**
 * Function to extract ID of YouTube url.
 * @param url ID or url of YouTube
 * @returns ID of video or playlist.
 */
function extractID(url) {
    const check = yt_validate(url);
    if (!check || check === 'search')
        throw new Error('This is not a YouTube url or videoId or PlaylistID');
    if (url.startsWith('https')) {
        if (url.indexOf('list=') === -1) {
            let video_id;
            if (url.includes('youtu.be/'))
                video_id = url.split('youtu.be/')[1].split(/(\?|\/|&)/)[0];
            else if (url.includes('youtube.com/embed/'))
                video_id = url.split('youtube.com/embed/')[1].split(/(\?|\/|&)/)[0];
            else if (url.includes('youtube.com/shorts/'))
                video_id = url.split('youtube.com/shorts/')[1].split(/(\?|\/|&)/)[0];
            else
                video_id = url.split('watch?v=')[1].split(/(\?|\/|&)/)[0];
            return video_id;
        }
        else {
            return url.split('list=')[1].split('&')[0];
        }
    }
    else
        return url;
}
exports.extractID = extractID;
/**
 * Basic function to get data from a YouTube url or ID.
 * @param url YouTube url or ID
 * @param options cookie and proxy parameters to add
 * @returns Data containing video_details, LiveStreamData and formats of video url.
 */
async function video_basic_info(url, options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    if (yt_validate(url) !== 'video')
        throw new Error('This is not a YouTube Watch URL');
    const video_id = extractID(url);
    const new_url = `https://www.youtube.com/watch?v=${video_id}&has_verified=1`;
    const body = await (0, index_1.request)(new_url, {
        proxies: (_a = options.proxy) !== null && _a !== void 0 ? _a : [],
        headers: { 'accept-language': 'en-US,en-IN;q=0.9,en;q=0.8,hi;q=0.7' },
        cookies: true
    });
    const player_data = (_c = (_b = body
        .split('var ytInitialPlayerResponse = ')) === null || _b === void 0 ? void 0 : _b[1]) === null || _c === void 0 ? void 0 : _c.split(';</script>')[0].split(/; (var|const|let)/)[0];
    if (!player_data)
        throw new Error('Initial Player Response Data is undefined.');
    const initial_data = (_e = (_d = body
        .split('var ytInitialData = ')) === null || _d === void 0 ? void 0 : _d[1]) === null || _e === void 0 ? void 0 : _e.split(';</script>')[0].split(/; (var|const|let)/)[0];
    if (!initial_data)
        throw new Error('Initial Response Data is undefined.');
    const player_response = JSON.parse(player_data);
    const initial_response = JSON.parse(initial_data);
    if (player_response.playabilityStatus.status !== 'OK')
        throw new Error(`While getting info from url\n${(_g = (_f = player_response.playabilityStatus.errorScreen.playerErrorMessageRenderer) === null || _f === void 0 ? void 0 : _f.reason.simpleText) !== null && _g !== void 0 ? _g : (_h = player_response.playabilityStatus.errorScreen.playerKavRenderer) === null || _h === void 0 ? void 0 : _h.reason.simpleText}`);
    const badge = ((_m = (_l = (_k = (_j = initial_response.contents.twoColumnWatchNextResults.results.results.contents[1]) === null || _j === void 0 ? void 0 : _j.videoSecondaryInfoRenderer) === null || _k === void 0 ? void 0 : _k.owner) === null || _l === void 0 ? void 0 : _l.videoOwnerRenderer) === null || _m === void 0 ? void 0 : _m.badges) &&
        ((_r = (_q = (_p = (_o = initial_response.contents.twoColumnWatchNextResults.results.results.contents[1]) === null || _o === void 0 ? void 0 : _o.videoSecondaryInfoRenderer) === null || _p === void 0 ? void 0 : _p.owner) === null || _q === void 0 ? void 0 : _q.videoOwnerRenderer) === null || _r === void 0 ? void 0 : _r.badges[0]);
    const html5player = `https://www.youtube.com${body.split('"jsUrl":"')[1].split('"')[0]}`;
    const related = [];
    initial_response.contents.twoColumnWatchNextResults.secondaryResults.secondaryResults.results.forEach((res) => {
        if (res.compactVideoRenderer)
            related.push(`https://www.youtube.com/watch?v=${res.compactVideoRenderer.videoId}`);
    });
    const format = [];
    const vid = player_response.videoDetails;
    const microformat = player_response.microformat.playerMicroformatRenderer;
    const video_details = new Video_1.YouTubeVideo({
        id: vid.videoId,
        url: `https://www.youtube.com/watch?v=${vid.videoId}`,
        title: vid.title,
        description: vid.shortDescription,
        duration: Number(vid.lengthSeconds),
        duration_raw: parseSeconds(Number(vid.lengthSeconds)),
        uploadedAt: microformat.publishDate,
        thumbnail: vid.thumbnail.thumbnails[vid.thumbnail.thumbnails.length - 1],
        channel: {
            name: vid.author,
            id: vid.channelId,
            url: `https://www.youtube.com/channel/${vid.channelId}`,
            verified: Boolean((_t = (_s = badge === null || badge === void 0 ? void 0 : badge.metadataBadgeRenderer) === null || _s === void 0 ? void 0 : _s.style) === null || _t === void 0 ? void 0 : _t.toLowerCase().includes('verified'))
        },
        views: vid.viewCount,
        tags: vid.keywords,
        averageRating: vid.averageRating,
        live: vid.isLiveContent,
        private: vid.isPrivate
    });
    format.push(...((_u = player_response.streamingData.formats) !== null && _u !== void 0 ? _u : []));
    format.push(...((_v = player_response.streamingData.adaptiveFormats) !== null && _v !== void 0 ? _v : []));
    const LiveStreamData = {
        isLive: video_details.live,
        dashManifestUrl: (_x = (_w = player_response.streamingData) === null || _w === void 0 ? void 0 : _w.dashManifestUrl) !== null && _x !== void 0 ? _x : null,
        hlsManifestUrl: (_z = (_y = player_response.streamingData) === null || _y === void 0 ? void 0 : _y.hlsManifestUrl) !== null && _z !== void 0 ? _z : null
    };
    return {
        LiveStreamData,
        html5player,
        format,
        video_details,
        related_videos: related
    };
}
exports.video_basic_info = video_basic_info;
/**
 * Function to convert seconds to [hour : minutes : seconds] format
 * @param seconds seconds to convert
 * @returns [hour : minutes : seconds] format
 */
function parseSeconds(seconds) {
    const d = Number(seconds);
    const h = Math.floor(d / 3600);
    const m = Math.floor((d % 3600) / 60);
    const s = Math.floor((d % 3600) % 60);
    const hDisplay = h > 0 ? (h < 10 ? `0${h}` : h) + ':' : '';
    const mDisplay = m > 0 ? (m < 10 ? `0${m}` : m) + ':' : '00:';
    const sDisplay = s > 0 ? (s < 10 ? `0${s}` : s) : '00';
    return hDisplay + mDisplay + sDisplay;
}
/**
 * Function which gets data from video_basic_info and deciphers it if it contains signatures.
 * @param url YouTube Video URL
 * @param options cookie and proxy parameters to add
 * @returns Data containing video_details, LiveStreamData and formats of video url.
 */
async function video_info(url, options = {}) {
    const data = await video_basic_info(url, options);
    if (data.LiveStreamData.isLive === true && data.LiveStreamData.hlsManifestUrl !== null) {
        return data;
    }
    else if (data.format[0].signatureCipher || data.format[0].cipher) {
        data.format = await (0, cipher_1.format_decipher)(data.format, data.html5player);
        return data;
    }
    else {
        return data;
    }
}
exports.video_info = video_info;
/**
 * Function uses data from video_basic_info and deciphers it if it contains signatures.
 * @param data basic_video_info data
 * @returns Data containing video_details, LiveStreamData and formats of video url.
 */
async function decipher_info(data) {
    if (data.LiveStreamData.isLive === true && data.LiveStreamData.hlsManifestUrl !== null) {
        return data;
    }
    else if (data.format[0].signatureCipher || data.format[0].cipher) {
        data.format = await (0, cipher_1.format_decipher)(data.format, data.html5player);
        return data;
    }
    else {
        return data;
    }
}
exports.decipher_info = decipher_info;
/**
 * Function to get YouTube playlist info from a playlist url.
 * @param url Playlist URL
 * @param options incomplete and proxy to add.
 * @returns YouTube Playlist
 */
async function playlist_info(url, options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    if (!url || typeof url !== 'string')
        throw new Error(`Expected playlist url, received ${typeof url}!`);
    let Playlist_id;
    if (url.startsWith('https')) {
        if (yt_validate(url) !== 'playlist')
            throw new Error('This is not a Playlist URL');
        Playlist_id = extractID(url);
    }
    else
        Playlist_id = url;
    const new_url = `https://www.youtube.com/playlist?list=${Playlist_id}`;
    const body = await (0, index_1.request)(new_url, {
        proxies: (_a = options.proxy) !== null && _a !== void 0 ? _a : undefined,
        headers: { 'accept-language': 'en-US,en-IN;q=0.9,en;q=0.8,hi;q=0.7' }
    });
    const response = JSON.parse(body.split('var ytInitialData = ')[1].split(';</script>')[0]);
    if (response.alerts) {
        if (((_b = response.alerts[0].alertWithButtonRenderer) === null || _b === void 0 ? void 0 : _b.type) === 'INFO') {
            if (!options.incomplete)
                throw new Error(`While parsing playlist url\n${response.alerts[0].alertWithButtonRenderer.text.simpleText}`);
        }
        else if (((_c = response.alerts[0].alertRenderer) === null || _c === void 0 ? void 0 : _c.type) === 'ERROR')
            throw new Error(`While parsing playlist url\n${response.alerts[0].alertRenderer.text.runs[0].text}`);
        else
            throw new Error('While parsing playlist url\nUnknown Playlist Error');
    }
    const rawJSON = `${body.split('{"playlistVideoListRenderer":{"contents":')[1].split('}],"playlistId"')[0]}}]`;
    const parsed = JSON.parse(rawJSON);
    const playlistDetails = JSON.parse(body.split('{"playlistSidebarRenderer":')[1].split('}};</script>')[0]).items;
    const API_KEY = (_g = (_e = (_d = body.split('INNERTUBE_API_KEY":"')[1]) === null || _d === void 0 ? void 0 : _d.split('"')[0]) !== null && _e !== void 0 ? _e : (_f = body.split('innertubeApiKey":"')[1]) === null || _f === void 0 ? void 0 : _f.split('"')[0]) !== null && _g !== void 0 ? _g : DEFAULT_API_KEY;
    const videos = getPlaylistVideos(parsed, 100);
    const data = playlistDetails[0].playlistSidebarPrimaryInfoRenderer;
    if (!data.title.runs || !data.title.runs.length)
        throw new Error('Failed to Parse Playlist info.');
    const author = (_h = playlistDetails[1]) === null || _h === void 0 ? void 0 : _h.playlistSidebarSecondaryInfoRenderer.videoOwner;
    const views = data.stats.length === 3 ? data.stats[1].simpleText.replace(/[^0-9]/g, '') : 0;
    const lastUpdate = (_l = (_k = (_j = data.stats
        .find((x) => 'runs' in x && x['runs'].find((y) => y.text.toLowerCase().includes('last update')))) === null || _j === void 0 ? void 0 : _j.runs.pop()) === null || _k === void 0 ? void 0 : _k.text) !== null && _l !== void 0 ? _l : null;
    const videosCount = data.stats[0].runs[0].text.replace(/[^0-9]/g, '') || 0;
    const res = new Playlist_1.YouTubePlayList({
        continuation: {
            api: API_KEY,
            token: getContinuationToken(parsed),
            clientVersion: (_q = (_o = (_m = body.split('"INNERTUBE_CONTEXT_CLIENT_VERSION":"')[1]) === null || _m === void 0 ? void 0 : _m.split('"')[0]) !== null && _o !== void 0 ? _o : (_p = body.split('"innertube_context_client_version":"')[1]) === null || _p === void 0 ? void 0 : _p.split('"')[0]) !== null && _q !== void 0 ? _q : '<some version>'
        },
        id: data.title.runs[0].navigationEndpoint.watchEndpoint.playlistId,
        title: data.title.runs[0].text,
        videoCount: parseInt(videosCount) || 0,
        lastUpdate: lastUpdate,
        views: parseInt(views) || 0,
        videos: videos,
        url: `https://www.youtube.com/playlist?list=${data.title.runs[0].navigationEndpoint.watchEndpoint.playlistId}`,
        link: `https://www.youtube.com${data.title.runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url}`,
        author: author
            ? {
                name: author.videoOwnerRenderer.title.runs[0].text,
                id: author.videoOwnerRenderer.title.runs[0].navigationEndpoint.browseEndpoint.browseId,
                url: `https://www.youtube.com${author.videoOwnerRenderer.navigationEndpoint.commandMetadata.webCommandMetadata.url ||
                    author.videoOwnerRenderer.navigationEndpoint.browseEndpoint.canonicalBaseUrl}`,
                icon: author.videoOwnerRenderer.thumbnail.thumbnails.length
                    ? author.videoOwnerRenderer.thumbnail.thumbnails[author.videoOwnerRenderer.thumbnail.thumbnails.length - 1].url
                    : null
            }
            : {},
        thumbnail: ((_r = data.thumbnailRenderer.playlistVideoThumbnailRenderer) === null || _r === void 0 ? void 0 : _r.thumbnail.thumbnails.length)
            ? data.thumbnailRenderer.playlistVideoThumbnailRenderer.thumbnail.thumbnails[data.thumbnailRenderer.playlistVideoThumbnailRenderer.thumbnail.thumbnails.length - 1]
            : null
    });
    return res;
}
exports.playlist_info = playlist_info;
/**
 * Function to parse Playlist from YouTube search
 * @param data html data of that request
 * @param limit No. of videos to parse
 * @returns Array of YouTubeVideo.
 */
function getPlaylistVideos(data, limit = Infinity) {
    var _a, _b, _c, _d;
    const videos = [];
    for (let i = 0; i < data.length; i++) {
        if (limit === videos.length)
            break;
        const info = data[i].playlistVideoRenderer;
        if (!info || !info.shortBylineText)
            continue;
        videos.push(new Video_1.YouTubeVideo({
            id: info.videoId,
            index: parseInt((_a = info.index) === null || _a === void 0 ? void 0 : _a.simpleText) || 0,
            duration: parseDuration((_b = info.lengthText) === null || _b === void 0 ? void 0 : _b.simpleText) || 0,
            duration_raw: (_d = (_c = info.lengthText) === null || _c === void 0 ? void 0 : _c.simpleText) !== null && _d !== void 0 ? _d : '0:00',
            thumbnail: {
                id: info.videoId,
                url: info.thumbnail.thumbnails[info.thumbnail.thumbnails.length - 1].url,
                height: info.thumbnail.thumbnails[info.thumbnail.thumbnails.length - 1].height,
                width: info.thumbnail.thumbnails[info.thumbnail.thumbnails.length - 1].width
            },
            title: info.title.runs[0].text,
            channel: {
                id: info.shortBylineText.runs[0].navigationEndpoint.browseEndpoint.browseId || undefined,
                name: info.shortBylineText.runs[0].text || undefined,
                url: `https://www.youtube.com${info.shortBylineText.runs[0].navigationEndpoint.browseEndpoint.canonicalBaseUrl ||
                    info.shortBylineText.runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url}`,
                icon: undefined
            }
        }));
    }
    return videos;
}
exports.getPlaylistVideos = getPlaylistVideos;
/**
 * Function to convert [hour : minutes : seconds] format to seconds
 * @param duration hour : minutes : seconds format
 * @returns seconds
 */
function parseDuration(duration) {
    duration !== null && duration !== void 0 ? duration : (duration = '0:00');
    const args = duration.split(':');
    let dur = 0;
    switch (args.length) {
        case 3:
            dur = parseInt(args[0]) * 60 * 60 + parseInt(args[1]) * 60 + parseInt(args[2]);
            break;
        case 2:
            dur = parseInt(args[0]) * 60 + parseInt(args[1]);
            break;
        default:
            dur = parseInt(args[0]);
    }
    return dur;
}
/**
 * Function to get Continuation Token
 * @param data html data of playlist url
 * @returns token
 */
function getContinuationToken(data) {
    var _a, _b, _c;
    const continuationToken = (_c = (_b = (_a = data.find((x) => Object.keys(x)[0] === 'continuationItemRenderer')) === null || _a === void 0 ? void 0 : _a.continuationItemRenderer.continuationEndpoint) === null || _b === void 0 ? void 0 : _b.continuationCommand) === null || _c === void 0 ? void 0 : _c.token;
    return continuationToken;
}
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=extractor.js.map